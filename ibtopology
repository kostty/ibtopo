#!/usr/bin/python

"""
Todo:
  * Add support for Intel's host naming style in ibnetdiscover, i.e.
    the hostname goes as the last word
  * Hide Switches= when empty and/or on demand (via argument)
  * Configurable switch names, e.g. switch, S, edge etc
  * Configurable levels of ISLs
"""

import os.path
import argparse
import subprocess
import re
import hostlist
import json
import xmltodict
from fractions import Fraction

class Fabric():

    tier_labels = ['', 'Switch', ('Edge', 'Core'), ('Edge', 'Leaf', 'Spine')]

    def __init__(self):
        self.switches = {}
        self.tiers = {}
        self.num_tiers=0

    @property
    def tier_names(self):
        return tier_labels[self.num_tiers]


def assign_tiers(switches):
    start_tier = [switch for switch in switches if len(switches[switch]['hosts'])]
    next_tier, next_tier_num = set_tier(switches, start_tier)
    while next_tier:
        next_tier, next_num = set_tier(switches, next_tier, next_tier_num)

    return next_num-1

def set_tier(switches, tier, tier_num = 1):
    for switch in tier:
        switches[switch]['tier'] = tier_num
    next_tier = [switch for switch in switches
                     if not 'tier' in switches[switch]]

    return next_tier, tier_num+1

switches = {}

script_name = os.path.basename(__file__)
tier_names = [['Switch'], ['Edge', 'Core'], ['Edge', 'Leaf', 'Spine']]
ibnetdiscover_cmd = '/usr/sbin/ibnetdiscover'
ibnetdiscover_args = ''

parser = argparse.ArgumentParser(description = '''`{}` parses `ibnetdiscover`
         output to generate a Slurm topology file and extract some other useful
         information'''.format(script_name))
parser.add_argument('-f', '--input-file', metavar='PATH',
                    help='A file containing an output of `ibnetdiscover`')
parser.add_argument('-d', '--dump', action='store_true',
                    help='Dump the internal structure in JSON')
parser.add_argument('-n', '--nodes-only', action='store_true',
                    help='Only list connected nodes, not switches')
parser.add_argument('-I', '--ibnetdiscover-path', metavar='PATH',
                    help='The full path to the `ibnetdiscover` program')
parser.add_argument('-A', '--ibnetdiscover-args', metavar='ARGS',
                    help='''Additional arguments to be passed to the
          `ibnetdiscover` program (needs to be quoted, e.g. -A"--help"''')
parser.add_argument('-P', '--prefix', default='Switch',
                    help='Prefix to use when generating switch names')
parser.add_argument('-O', '--omni-path', action='store_true',
                    help='The fabric is based on Intel\'s Omni-Path')
args = parser.parse_args()
args = vars(args)

input_file = args['input_file']
prefix = args['prefix']
nodes_only = args['nodes_only']
omnipath = args['omni_path']

if args['ibnetdiscover_path']:
    ibnetdiscover_cmd = args['ibnetdiscover_path']

if args['ibnetdiscover_args']:
    ibnetdiscover_args = args['ibnetdiscover_args']

if input_file:
    try:
        f = open(input_file, 'r')
    except IOError as e:
        print('Error: {}: "{}"'.format(e.strerror, input_file))
        exit(2)
else:
    cmd = [ ibnetdiscover_cmd ]
    cmd.append(ibnetdiscover_args)
    cmd_str = ' '.join(cmd)
    try:
        f = subprocess.check_output(cmd, stderr=subprocess.STDOUT)
        f = f.split('\n')
    except OSError as e:
        if e.errno == 2:
            print('Error: `{}` couldn\'t be found'.format(cmd_str))
            exit(3)
    except subprocess.CalledProcessError as e:
        print('`{}` exited with rc={}\n'.format(cmd_str, e.returncode))
        print('The error message was as follows:\n\n {}'.format(e.output))
        exit(4)

if omnipath:
    report = xmltodict.parse(f)['Report']
    systems = report['ComponentSummary']['Systems']['System']
    links = report['LinkSummary']['Link']
    for sys in systems:
        if int(sys['ConnectedNodes']) > 1:
            parent_guid = sys['SystemImageGUID']
            switches[parent_guid] = {
                'ports': 0,
                'parent': None,
                'director': True,
                'hosts': {},
                'switches': {},
                }
            for node in sys['Node']:
                guid = node['NodeGUID']
                names = node['NodeDesc'].split()
                ports = int(node['NumPorts'])
                switches[guid] = {
                    'name': names[1],
                    'ports': ports,
                    'parent': parent_guid,
                    'director': False,
                    'hosts': {},
                    'switches': {},
                    }
                if names[1].startswith('L'):
                    # Below, 16 is an assumption based on the current
                    # Intel's director models. Couldn't derive it from
                    # the XML.
                    switches[parent_guid]['ports'] += 16
                switches[parent_guid]['name'] = names[0]
        elif sys['Node']['NodeType_Int'] == "2":
            guid = sys['Node']['NodeGUID']
            name = sys['Node']['NodeDesc']
            ports = int(sys['Node']['NumPorts'])
            switches[guid] = {
                'name': name,
                'ports': ports,
                'parent': None,
                'director': False,
                'hosts': {},
                'switches': {},
                }

    #json.dumps(switches, indent=4)
    for link in links:
        if int(link['Internal']):
            continue
        sw_guids = []
        for port in link['Port']:
            if port['NodeType_Int'] == '1':
                host_guid = port['NodeGUID']
                names = port['NodeDesc'].split()
                host = {
                    'name': names[0],
                    'hca': names[1],
                    'links': 1,
                    }
            else:
                guid = port['NodeGUID']
                if switches[guid]['parent']:
                    sw_guids.append(switches[guid]['parent'])
                else:
                    sw_guids.append(guid)
        if len(sw_guids) == 1:
            switch = switches[sw_guids[0]]
            if host_guid in switch['hosts']:
                switch['hosts'][host_guid]['links'] += 1
            else:
                switch['hosts'][host_guid] = host
        else:
            switchA = switches[sw_guids[0]]
            switchB = switches[sw_guids[1]]
            if sw_guids[0] in switchB['switches']:
                switchB['switches'][sw_guids[0]]['links'] += 1
            else:
                switchB['switches'][sw_guids[0]] = {'links': 1}
            if sw_guids[1] in switchA['switches']:
                switchA['switches'][sw_guids[1]]['links'] += 1
            else:
                switchA['switches'][sw_guids[1]] = {'links': 1}

#    switches = report

else:
    in_switch = False
    for line in f:
        line = line.rstrip()
        if re.match('Switch.*', line):
            parts = line.split('"',4)
            guid, name = parts[1], parts[3]
            lid = re.search('.* lid (\d+) .*', parts[4]).group(1)
            ports = int(re.split('\s+', parts[0])[1])
            switches[guid] = {
                'name': name,
                'lid': lid,
                'ports': ports,
                'hosts': {},
                'switches': {},
                'parent': None,
                }
            in_switch = guid
        elif re.match('\[.*', line):
            if not in_switch:
                continue
            switch = switches[in_switch]
            parts = line.split('"',4)
            guid = parts[1]
            name = parts[3]
            lid = re.search('.* lid (\d+) .*', parts[4]).group(1)
            remote_port = parts[2].strip(' #[]')
            if re.match('H-', guid):
                name = name.split(' ')
                hca, name = name[1], name[0]
                if guid in switch['hosts']:
                    switch['hosts'][guid]['links'] += 1
                else:
                    switch['hosts'][guid] = {
                        'links': 1,
                        'lid': lid,
                        'name': name,
                        'hca': hca,
                        }
            elif re.match('S-', guid):
                if guid in switch['switches']:
                    switch['switches'][guid]['links'] += 1
                else:
                    switch['switches'][guid] = {'links': 1}
        else:
            in_switch = False

#max_tier = assign_tiers(switches)

if args['dump']:
    print(json.dumps(switches, indent=4))
else:
    num2guid = {}
    output = [[], []]
    out_len = 0
    switches = {k: v for k, v in switches.items() if not v['parent']}
    for i, guid in enumerate(switches):
        num2guid[guid] = i+1
    for guid, info in switches.items():
        if info['parent']:
            continue
        switch = '{}{}'.format(prefix, num2guid[guid])
        nodes = [ n['name'] for n in info['hosts'].values() ]
        n_links = sum([n['links'] for n in info['hosts'].values()])
        sw_links = sum([s['links'] for s in info['switches'].values()])
        nodes = hostlist.collect_hostlist(nodes)
        out_str = 'SwitchName={} Nodes={}'.format(switch, nodes)
        if not nodes_only:
            isl = [ '{}{}'.format(prefix,
                                       num2guid[x]) for x in info['switches']]
            isl = hostlist.collect_hostlist(isl)
            out_str += ' Switches={}'.format(isl)
        comment = '# Free ports: {}'.format(info['ports'] - 
                                            (n_links + sw_links))
        if n_links:
            b_factor = Fraction(info['ports'] - sw_links, sw_links)
            comment += ',\tblocking-factor: {}:{}'.format(b_factor.numerator,
                                                        b_factor.denominator)
        else:
            comment += ',\tblocking-factor: N/A'
        if 'tier' in info:
            comment += ',\ttier: {}'.format(tier_names[max_tier-1][info['tier']-1])
	out_len = max(len(out_str), out_len)
	output[0].append(out_str)
	output[1].append(comment)

    output = ['{:<{}} {}'.format(out_str, out_len, comment) for out_str, comment in zip(output[0], output[1])]
    print('\n'.join(output))

