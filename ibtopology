#!/usr/bin/python

"""
Todo:
  * Add support for Intel's host naming style in ibnetdiscover, i.e.
    the hostname goes as the last word
  * Hide Switches= when empty and/or on demand (via argument)
  * Configurable switch names, e.g. switch, S, edge etc
  * Configurable levels of ISLs
"""

import os.path
import argparse
import subprocess
import re
import hostlist
import json
import xmltodict
from fractions import Fraction


#/////////////// Class(es)

class Fabric():

    tier_labels = ['', 'Switch', ('Edge', 'Core'), ('Edge', 'Leaf', 'Spine')]

    def __init__(self):
        self.switches = {}
        self.tiers = {}
        self.num_tiers=0

    @property
    def tier_names(self):
        return tier_labels[self.num_tiers]


#///////////////// Functions

def assign_tiers(switches):
    start_tier = [switch for switch in switches if len(switches[switch]['hosts'])]
    next_tier, next_tier_num = set_tier(switches, start_tier)
    while next_tier:
        next_tier, next_num = set_tier(switches, next_tier, next_tier_num)

    return next_num-1

def set_tier(switches, tier, tier_num = 1):
    for switch in tier:
        switches[switch]['tier'] = tier_num
    next_tier = [switch for switch in switches
                     if not 'tier' in switches[switch]]

    return next_tier, tier_num+1

def setup_guid_mapping(topo, gen_names, prefix):
    '''Return a mapper function, that maps a switch's GUID to its name

    Args:
        topo (dict): Switches in the fabrica (in case of a director, leaf
                     and spine modules omitted)
        gen_names (bool): If new names should be generated in format of
                          `prefix+N`
        prefix (str): The prefix to use for new names
    '''

    guid_to_name_map = {}
    if gen_names:
        for i, guid in enumerate(topo):
            guid_to_name_map[guid] = '{}{}'.format(prefix, i+1)
    else:
        for guid, info in topo.items():
            guid_to_name_map[guid] = info['name']

    def guid_to_name(guid):
        return guid_to_name_map[guid]

    return guid_to_name

def print_lines(lines):
    for line in lines:
        print line

def join_items(lst, sep1, sep2):
    '''Form a string of text from a list of tuples (`Name`, `Value`)

    Args:
        lst (list): List of tuples to join into a string
        sep1 (str): Separator to join items of tuples with
        sep2 (str): Separator to join items of the list with'''

    def parse_tuple(item):
        return sep1.join(item)

    out = []
    for item in lst:
        if len(item) == 1:
            item = (item[0], '')
        if isinstance(item[1], list):
            #return join_items(item[1], sep1, sep2)
            item = (item[0], join_items(item[1], sep1, sep2))

        out.append(sep1.join(item))

    return sep2.join(out)

def pad_items(lst):
    max_len = 0
    for item in lst:
        max_len = max(len(item), max_len)

    return '{:<{}}'.format(item, max_len)

def get_recursive_item(lst, ind):
    '''
    Traverse a list of Lists (of tuples) and return a list of the ind-th
    elements from each List.
    '''
    return [x[ind][1] for x in lst]

def pad_table(lst):
    '''
    Pad every `value` part of the table
    '''

    for i in lst:
        pass 

def count_links(dct, do_map):
    '''
    Group connected switches/nodes by the count of links
    '''
    by_count = {}

    for guid, info in dct.items():
        if info['links'] not in by_count:
             by_count[info['links']] = []
        if do_map:
            name = guid_to_name(guid)
        else:
            name = info['name']
        by_count[info['links']].append(name)
    for count, names in by_count.items():
        by_count[count] = hostlist.collect_hostlist(names)
    
    return by_count

#///////////////// Code

switches = {}

script_name = os.path.basename(__file__)
tier_names = [['Switch'], ['Edge', 'Core'], ['Edge', 'Leaf', 'Spine']]
ibnetdiscover_cmd = '/usr/sbin/ibnetdiscover'
ibnetdiscover_args = ''

parser = argparse.ArgumentParser(description = '''`{}` parses `ibnetdiscover`
         output to generate a Slurm topology file and extract some other useful
         information'''.format(script_name))
parser.add_argument('-f', '--input-file', metavar='PATH',
                    help='A file containing an output of `ibnetdiscover`')
parser.add_argument('-d', '--dump', action='store_true',
                    help='Dump the internal structure in JSON')
parser.add_argument('-n', '--nodes-only', action='store_true',
                    help='Only list connected nodes, not switches')
parser.add_argument('-I', '--ibnetdiscover-path', metavar='PATH',
                    help='The full path to the `ibnetdiscover` program')
parser.add_argument('-A', '--ibnetdiscover-args', metavar='ARGS',
                    help='''Additional arguments to be passed to the
          `ibnetdiscover` program (needs to be quoted, e.g. -A"--help"''')
parser.add_argument('-P', '--prefix', default='Switch',
                    help='Prefix to use when generating switch names')
parser.add_argument('-O', '--omni-path', action='store_true',
                    help='The fabric is based on Intel\'s Omni-Path')
parser.add_argument('-N', '--no-mapping', action='store_true',
                    help='Switch name mapping isn\'t needed, '
                         'as it\'s probably has already been handled'
                         'outside of the script')
parser.add_argument('-S', '--no-slurm', action='store_true',
                    help='Print not in Slurm format')
args = parser.parse_args()
args = vars(args)

input_file = args['input_file']
prefix = args['prefix']
nodes_only = args['nodes_only']
omnipath = args['omni_path']
do_mapping = not args['no_mapping']
no_slurm = args['no_slurm']

if args['ibnetdiscover_path']:
    ibnetdiscover_cmd = args['ibnetdiscover_path']

if args['ibnetdiscover_args']:
    ibnetdiscover_args = args['ibnetdiscover_args']

if input_file:
    try:
        f = open(input_file, 'r')
    except IOError as e:
        print('Error: {}: "{}"'.format(e.strerror, input_file))
        exit(2)
else:
    cmd = [ ibnetdiscover_cmd ]
    cmd.append(ibnetdiscover_args)
    cmd_str = ' '.join(cmd)
    try:
        f = subprocess.check_output(cmd, stderr=subprocess.STDOUT)
        f = f.split('\n')
    except OSError as e:
        if e.errno == 2:
            print('Error: `{}` couldn\'t be found'.format(cmd_str))
            exit(3)
    except subprocess.CalledProcessError as e:
        print('`{}` exited with rc={}\n'.format(cmd_str, e.returncode))
        print('The error message was as follows:\n\n {}'.format(e.output))
        exit(4)


# Save for later use
#        sorted_guids = sorted(
#                switches,
#                key=lambda guid: len(switches[guid]['hosts']),
#                reverse=True,
#                )


if omnipath:
    report = xmltodict.parse(f)['Report']
    systems = report['ComponentSummary']['Systems']['System']
    links = report['LinkSummary']['Link']
    for sys in systems:
        if int(sys['ConnectedNodes']) > 1:
            parent_guid = sys['SystemImageGUID']
            switches[parent_guid] = {
                'ports': 0,
                'parent': None,
                'director': True,
                'hosts': {},
                'switches': {},
                }
            for node in sys['Node']:
                guid = node['NodeGUID']
                names = node['NodeDesc'].split()
                ports = int(node['NumPorts'])
                switches[guid] = {
                    'name': names[1],
                    'ports': ports,
                    'parent': parent_guid,
                    'director': False,
                    'hosts': {},
                    'switches': {},
                    }
                if names[1].startswith('L'):
                    # Below, 16 is an assumption based on the current
                    # Intel's director models. Couldn't derive it from
                    # the XML.
                    switches[parent_guid]['ports'] += 16
                switches[parent_guid]['name'] = names[0]
        elif sys['Node']['NodeType'] == 'SW':
            guid = sys['Node']['NodeGUID']
            name = sys['Node']['NodeDesc']
            ports = int(sys['Node']['NumPorts'])
            switches[guid] = {
                'name': name,
                'ports': ports,
                'parent': None,
                'director': False,
                'hosts': {},
                'switches': {},
                }

    #json.dumps(switches, indent=4)
    for link in links:
        if int(link['Internal']):
            continue
        sw_guids = []
        for port in link['Port']:
            if port['NodeType'] == 'FI':
                host_guid = port['NodeGUID']
                names = port['NodeDesc'].split()
                if len(names) == 1:
                    names.append('N/A')
                host = {
                    'name': names[0],
                    'hca': names[1],
                    'links': 1,
                    }
            elif port['NodeType'] == 'SW':
                guid = port['NodeGUID']
                if switches[guid]['parent']:
                    sw_guids.append(switches[guid]['parent'])
                else:
                    sw_guids.append(guid)
            else:
                print('Oops, an unknown port type encountered: `{}`!'.format(
                            port['NodeType']))
        if len(sw_guids) == 1:
            switch = switches[sw_guids[0]]
            if host_guid in switch['hosts']:
                switch['hosts'][host_guid]['links'] += 1
            else:
                switch['hosts'][host_guid] = host
        else:
            switchA = switches[sw_guids[0]]
            switchB = switches[sw_guids[1]]
            if sw_guids[0] in switchB['switches']:
                switchB['switches'][sw_guids[0]]['links'] += 1
            else:
                switchB['switches'][sw_guids[0]] = {'links': 1}
            if sw_guids[1] in switchA['switches']:
                switchA['switches'][sw_guids[1]]['links'] += 1
            else:
                switchA['switches'][sw_guids[1]] = {'links': 1}

#    switches = report

else:
    in_switch = False
    for line in f:
        line = line.rstrip()
        if re.match('Switch.*', line):
            parts = line.split('"',4)
            guid, name = parts[1], parts[3]
            lid = re.search('.* lid (\d+) .*', parts[4]).group(1)
            ports = int(re.split('\s+', parts[0])[1])
            switches[guid] = {
                'name': name,
                'lid': lid,
                'ports': ports,
                'hosts': {},
                'switches': {},
                'parent': None,
                }
            in_switch = guid
        elif re.match('\[.*', line):
            if not in_switch:
                continue
            switch = switches[in_switch]
            parts = line.split('"',4)
            guid = parts[1]
            name = parts[3]
            lid = re.search('.* lid (\d+) .*', parts[4]).group(1)
            remote_port = parts[2].strip(' #[]')
            if re.match('H-', guid):
                name = name.split(' ')
                hca, name = name[1], name[0]
                if guid in switch['hosts']:
                    switch['hosts'][guid]['links'] += 1
                else:
                    switch['hosts'][guid] = {
                        'links': 1,
                        'lid': lid,
                        'name': name,
                        'hca': hca,
                        }
            elif re.match('S-', guid):
                if guid in switch['switches']:
                    switch['switches'][guid]['links'] += 1
                else:
                    switch['switches'][guid] = {'links': 1}
        else:
            in_switch = False

#max_tier = assign_tiers(switches)

if args['dump']:
    print(json.dumps(switches, indent=4))
else:
    output = []
    link_info = []
    out_len = 0
    switches = {k: v for k, v in switches.items() if not v['parent']}
    
    guid_to_name = setup_guid_mapping(topo=switches,
                                      gen_names=do_mapping,
                                      prefix=prefix)

    for guid, info in switches.items():
        switch_links = {}
        node_links = {}
        comment = []
        link_str = []
        outl = []
        coml = []
        
        if info['parent']:
            continue
        
        switch = '{}'.format(guid_to_name(guid))
        nodes = [ n['name'] for n in info['hosts'].values() ]
        nodes = hostlist.collect_hostlist(nodes)
        #out_str = 'SwitchName={} Nodes={}'.format(switch, nodes)
        outl.append(('SwitchName', switch))
        outl.append(('Nodes', nodes))
        if not nodes_only:
            isl = ['{}'.format(guid_to_name(x)) for x in info['switches']]
            isl = hostlist.collect_hostlist(isl)
            #out_str += ' Switches={}'.format(isl)
            outl.append(('Switches', isl))
        n_links = sum([n['links'] for n in info['hosts'].values()])
        sw_links = sum([s['links'] for s in info['switches'].values()])
        free_ports = info['ports'] - (n_links + sw_links)
        coml.append(('Free ports', str(free_ports)))
        comment.append(
                'Free ports: {}'.format(info['ports'] - n_links + sw_links)
                )
        if n_links:
            b_factor = Fraction(info['ports'] - sw_links, sw_links)
            b_factor = '{}:{}'.format(b_factor.numerator,b_factor.denominator)
        else:
            b_factor = 'N/A'
        #comment.append('blocking-factor: {}'.format(b_factor))
        coml.append(('blocking', b_factor))
        if 'tier' in info:
            comment.append('tier: {}'.format(tier_names[max_tier-1][info['tier']-1]))

        switch_links = [(nam, str(cnt)) for cnt, nam in
                count_links(info['switches'], do_map=True).items()]
#        for nb_guid, nb_info in info['switches'].items():
#            if nb_info['links'] not in switch_links:
#                switch_links[nb_info['links']] = []
#            switch_links[nb_info['links']].append(guid_to_name(nb_guid))
#        for num_links, switch_names in switch_links.items():
#            switch_names = hostlist.collect_hostlist(switch_names)
#            #link_str.append(
#               '{}: {}'.format(hostlist.collect_hostlist(switch_names), num_links))

        node_links = [(nam, str(cnt)) for cnt, nam in
                count_links(info['hosts'], do_map=False).items()]
#        for nb_guid, nb_info in info['hosts'].items():
#            if nb_info['links'] not in node_links:
#                node_links[nb_info['links']] = []
#            node_links[nb_info['links']].append(nb_info['name'])
#        for num_links, node_name in node_links.items():
#            link_str.append('{}: {}'.format(
#                hostlist.collect_hostlist(node_name), num_links))
#
        #link_str = ', '.join(link_str)
        #comment_str = ',\t'.join(comment)
        #out_len = max(len(out_str), out_len)
    	#output.append((out_str, comment_str, link_str))
        if no_slurm:
            output.append(
                join_items(
                    [(switch, [('Switches', switch_links), ('Hosts',
                        node_links)])],
                    sep1=': ', sep2=', '))
        else:
        	output.append('{}\t# {}'.format(join_items(outl,'=',' '),
                    join_items(coml,': ',', ')))

    #output = ['{:<{}} # {}\n# Links: {}\n'.format(out_str, out_len, comment, link_info)
    #          for (out_str, comment, link_info) in output]
    print_lines(output)

